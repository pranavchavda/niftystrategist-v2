#!/usr/bin/env python3
"""Place, view, and cancel stock orders.

NOTE: place and cancel subcommands are HITL-protected â€” they require
user approval when called from the orchestrator via execute_bash.
When called directly from the terminal, they execute immediately.
"""

import argparse
import sys
import os

_backend_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
if _backend_dir not in sys.path:
    sys.path.insert(0, _backend_dir)

from base import SYMBOLS, format_inr, init_client, print_error, print_json, print_success, run_async, validate_symbol  # noqa: E402


def place_order(symbol: str, action: str, quantity: int, order_type: str,
                price: float | None, stop_loss: float | None, target: float | None,
                dry_run: bool, as_json: bool, amo: bool = False, product: str = "D"):
    """Place a buy or sell order."""
    sym = validate_symbol(symbol)
    act = action.upper()
    if act not in ("BUY", "SELL"):
        print_error(f"Action must be BUY or SELL, got: {act}")
    if order_type == "LIMIT" and price is None:
        print_error("Limit orders require --price.")
    if quantity < 1:
        print_error("Quantity must be at least 1.")

    client = init_client()

    # Get current price for context
    try:
        quote = run_async(client.get_quote(sym))
        ltp = quote["ltp"]
    except Exception:
        ltp = None

    if dry_run:
        result = {
            "dry_run": True,
            "symbol": sym,
            "action": act,
            "quantity": quantity,
            "order_type": order_type,
            "price": price,
            "product": product,
            "current_ltp": ltp,
            "stop_loss": stop_loss,
            "target": target,
            "estimated_value": (price or ltp or 0) * quantity,
        }
        if as_json:
            print_json(result)
        else:
            print(f"ðŸ” Dry Run â€” order NOT placed\n")
            print(f"  {act} {quantity}x {sym} @ {order_type}")
            print(f"  Product:   {'Intraday (MIS)' if product == 'I' else 'Delivery (CNC)'}")
            if price:
                print(f"  Limit Price: {format_inr(price)}")
            if ltp:
                print(f"  Current LTP: {format_inr(ltp)}")
            print(f"  Est. Value:  {format_inr(result['estimated_value'])}")
            if stop_loss:
                print(f"  Stop Loss:   {format_inr(stop_loss)}")
            if target:
                print(f"  Target:      {format_inr(target)}")
        return

    try:
        order_result = run_async(client.place_order(
            symbol=sym,
            transaction_type=act,
            quantity=quantity,
            order_type=order_type,
            price=price if price else 0,
            is_amo=True if amo else None,  # True=force AMO, None=auto-detect
            product=product,
        ))
    except Exception as e:
        print_error(f"Order failed: {e}")

    if not order_result.success:
        print_error(f"Order failed: {order_result.message}")

    if as_json:
        print_json({
            "success": True,
            "order_id": order_result.order_id,
            "symbol": sym,
            "action": act,
            "quantity": quantity,
            "order_type": order_type,
            "executed_price": order_result.executed_price,
            "status": order_result.status,
            "mode": "paper" if client.paper_trading else "live",
        })
    else:
        mode = "Paper" if client.paper_trading else "ðŸ”´ LIVE"
        emoji = "ðŸŸ¢" if act == "BUY" else "ðŸ”´"
        print_success(f"Order Placed [{mode}]")
        print(f"\n  {emoji} {act} {quantity}x {sym}")
        print(f"  Order ID: {order_result.order_id}")
        print(f"  Type:     {order_type}")
        if order_result.executed_price:
            print(f"  Price:    {format_inr(order_result.executed_price)}")
        print(f"  Status:   {order_result.status}")


def show_orders(open_only: bool, limit: int, as_json: bool):
    """Show open or recent orders."""
    client = init_client()
    try:
        orders = run_async(client.get_orders())
    except Exception as e:
        print_error(f"Failed to get orders: {e}")

    if not orders:
        if as_json:
            print_json({"orders": [], "message": "No orders found"})
        else:
            print("ðŸ“­ No orders found.")
        return

    if open_only:
        orders = [o for o in orders if o.get("status") in ("open", "pending", "trigger_pending")]

    orders = orders[:limit]

    if as_json:
        print_json({"orders": orders})
        return

    label = "Open Orders" if open_only else "Order History"
    print(f"ðŸ“‹ {label}\n")
    print(f"{'Order ID':<12} {'Symbol':<12} {'Action':<6} {'Qty':>5} {'Type':<8} {'Price':>12} {'Status':<12}")
    print("-" * 72)

    status_emoji = {
        "complete": "âœ…", "executed": "âœ…", "rejected": "âŒ",
        "cancelled": "ðŸš«", "open": "â³", "pending": "â³",
    }

    for o in orders:
        oid = str(o.get("order_id", ""))[:10]
        price_str = format_inr(o.get("average_price") or o.get("price")) if o.get("average_price") or o.get("price") else "MARKET"
        status = o.get("status", "unknown")
        emoji = status_emoji.get(status.lower(), "â“")
        print(
            f"{oid:<12} {o.get('symbol', '?'):<12} {o.get('transaction_type', '?'):<6} "
            f"{o.get('quantity', 0):>5} {o.get('order_type', '?'):<8} {price_str:>12} {emoji} {status:<10}"
        )


def cancel_order(order_id: str, as_json: bool):
    """Cancel an open order."""
    client = init_client()
    try:
        result = run_async(client.cancel_order(order_id))
    except Exception as e:
        print_error(f"Failed to cancel order: {e}")

    if as_json:
        print_json(result)
    elif result.get("success"):
        print_success(f"Order {order_id} cancelled.")
    else:
        print_error(f"Cancel failed: {result.get('message', 'Unknown error')}")


def main():
    parser = argparse.ArgumentParser(
        prog="nf-order",
        description="Place, view, and cancel stock orders",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  nf-order buy RELIANCE 10                     Market buy 10 shares
  nf-order buy RELIANCE 10 --type LIMIT --price 1450   Limit buy
  nf-order buy RELIANCE 10 --dry-run           Preview without executing
  nf-order sell TCS 5                           Market sell (AMO auto-detected)
  nf-order sell TCS 5 --amo                      Force after-market order
  nf-order list                                 Show open orders
  nf-order list --all --limit 20                Show all recent orders
  nf-order cancel ORDER_ID                      Cancel an order
  nf-order buy RELIANCE 10 --json               JSON output
""",
    )

    sub = parser.add_subparsers(dest="command", help="Command")

    # buy / sell
    for cmd in ("buy", "sell"):
        p = sub.add_parser(cmd, help=f"{cmd.title()} shares")
        p.add_argument("symbol", help="Stock symbol")
        p.add_argument("quantity", type=int, help="Number of shares")
        p.add_argument("--type", dest="order_type", default="MARKET", choices=["MARKET", "LIMIT"], help="Order type")
        p.add_argument("--price", type=float, help="Limit price (required for LIMIT orders)")
        p.add_argument("--sl", type=float, help="Stop loss price")
        p.add_argument("--target", type=float, help="Target price")
        p.add_argument("--product", default="D", choices=["D", "I"],
                       help="Product type: D=Delivery/CNC, I=Intraday/MIS (default: D)")
        p.add_argument("--amo", action="store_true", help="Force after-market order (auto-detected if omitted)")
        p.add_argument("--dry-run", action="store_true", help="Preview order without executing")
        p.add_argument("--json", action="store_true", help="Output as JSON")

    # list
    p_list = sub.add_parser("list", help="Show orders")
    p_list.add_argument("--all", action="store_true", help="Show all orders (not just open)")
    p_list.add_argument("--limit", type=int, default=10, help="Max orders to show (default: 10)")
    p_list.add_argument("--json", action="store_true", help="Output as JSON")

    # cancel
    p_cancel = sub.add_parser("cancel", help="Cancel an open order")
    p_cancel.add_argument("order_id", help="Order ID to cancel")
    p_cancel.add_argument("--json", action="store_true", help="Output as JSON")

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        sys.exit(1)

    if args.command in ("buy", "sell"):
        place_order(
            symbol=args.symbol,
            action=args.command.upper(),
            quantity=args.quantity,
            order_type=args.order_type,
            price=args.price,
            stop_loss=args.sl,
            target=args.target,
            dry_run=args.dry_run,
            as_json=args.json,
            amo=args.amo,
            product=args.product,
        )
    elif args.command == "list":
        show_orders(open_only=not args.all, limit=args.limit, as_json=args.json)
    elif args.command == "cancel":
        cancel_order(args.order_id, as_json=args.json)


if __name__ == "__main__":
    main()
